@[TOC](volatile修饰符详解)
# volatile修饰的变量是怎么做到各线程可见的
- 1、cpu某个core在写volatile变量时，会将该变量`立刻写回到系统内存`(未用volatile修饰会先写到cpu内部缓存，之后某个时刻再写到系统内存)
- 2、写回系统内存后，通过`缓存一致性协议`，每个core通过嗅探在总线传播的数据来检查自己的缓存值是否过期了，当该core发现自己的缓冲行对应的内存地址被修改，就将自己的缓冲行设为无效，当该core对这个数据进行修改操作时，会重新从系统内存中把数据读到缓存里。

# volatile为什么不能保证共享变量的线程安全
> 原因：volatile只能保证多个core看到共享变量的修改，但是在假如两个线程A和B操作volatile修饰的变量count，A和B同时看到count值=100，然后同时进行+1操作，那么这时结果是101，而不是正确的102

> 当然也有特例，假如机器只有一个core，volatile修饰的共享变量是可以做到线程安全的


